# 쿠버네티스와 컨테이너

## 컨테이너와 도커

### 가상화와 컨테이너

![2.1-virtualization-container.png](images%2F2.1-virtualization-container.png)

### 도커 컨테이너

- 도커는 BSD와 솔라리스(Solaris)와 같은 유닉스(Unix) 운영체제에서 수십년간 사용되었던 개념이 현대적으로 재탄생된 최신 개념이다.
- 각 애플리케이션과 종속물이 운영체제 리소스의 분리된 세그먼트를 사용하는 방식이다.
- 컨테이너 런타임은 호스트 운영체제가 제공하는 저수준 컨테이너 서비스를 사용하여 컨테이너를 셋업하거나 없앤다.

1. 도커 컨테이너 분리 및 조절 기능을 제공
   - 도커 컨테이너는 앱을 서로 분리하거나 기반이 되는 시스템으로부터 계속 분리한다.
   - 동시에 더 쉽게 분리된 특정 애플리케이션의 CPU, GPU, 메모리, I/O, 네트워킹 등 시스템 리소스 사용 방식을 규정한다.
2. 이식성을 제공하는 도커 컨테이너
   - 도커 컨테이너는 컨테이너 런타임 환경을 지원하는 모든 장치에서 실행이 가능하다.
   - 애플리케이션을 호스트 운영체제와 연결할 필요가 없다.
3. 결합성(Composability)을 제공하는 도커 컨테이너
   - 대부분의 비즈니스 애플리케이션은 웹서버, 데이터베이스, 인-메모리 캐시 등 하나의 스택으로 구성되는 여러 별개의 구성 요소로 구성된다.
   - 컨테이너는 이런 조각들을 쉽게 변경할 수 있는 부품으로 구성된 기능 단위로 결합된다.
   - 애플리케이션 디자인의 마이크로서비스 모델이다.
4. 오케스트레이션과 스케일링이 쉬운 도커 컨테이너
   - 컨테이너는 가볍고, 오버헤드가 거의 없다.
   - 여러 시스템에서의 애플리케이션 스케일링, 수요 증가와 리소스 보존을 위한 서비스 증가 및 다운에도 컨테이너를 사용할 수 있다.
5. 가상 머신이 아닌 도커 컨테이너
   - 가상 머신은 운영체제에서 자신의 인스턴스에서 실행되기 때문에 고수준의 프로세스 분리 기능을 제공한다.
   - 컨테이너는 호스트 운영체제에서 통제된 영역을 사용한다.
   - 많은 애플리케이션이 철저히 관리되는 방식으로 동일한 운영체제 커널을 공유한다.
6. 변경이 불가능하고, 비저장성이 특징인 도커 컨테이너
   - 컨테이너는 내용을 설명하는 이미지로부터 부팅 및 실행된다. 
   - 이미지는 기본적으로 변경이 불가능하며 일단 생성되면 바뀌지 않는다.
7. 마이크로서비스가 아닌 도커 컨테이너
   - 컨테이너를 사용하면 더 쉽게 마이크로서비스 애플리케이션을 구현할 수 있다.
   - 특정 애플리케이션을 가져와 컨테이너에 연결하면 자동으로 마이크로서비스가 생성된다는 의미는 아니다.
   - 애플리케이션을 마이크로서비스로 변환하는 프로세스의 일부로 컨테이너화할 수 있지만, 수많은 방법들 중 하나일 뿐이다.

---

## 쿠버네티스와 데브옵스 운영

### 쿠버네티스 구조 및 데브옵스 운영 방식

![2.2-kubernetes-architecture-devops-operation.png](images%2F2.2-kubernetes-architecture-devops-operation.png)

- 자세한 내용은 [공식 문서](www.bigdatatraining.in)를 참고한다.

### 쿠버네티스와 데브옵스

- 컨테이너 기술은 민첩성을 확보하는 핵심 가상화 기술이며, 컨테이너 기반의 가상화 환경을 운영 관리하는 핵심 기술이 쿠버네티스다.
- 쿠버네티스는 컨테이너화된 애플리케이션을 자동으로 배포, 스케일링 및 관리해주는 오픈소스다.
- 마이크로서비스 아키텍처를 쉽게 발전시킬 수 있다.
- 데브옵스 모델을 쉽게 성숙시킬 수 있다.
- Docker 이외에도 rkt나 Hyper container등 다양한 컨테이너 엔진들을 지원한다.
- 하드웨어 자원을 컨테이너화하여 isolation하는 기능이 가능하다.
- 스토리지 자원을 활용하는 것이 용이하다.
- 노드 확장 등의 기능을 유연하게 지원한다.
- 자원을 최대한 최적화하여 사용하기 위해 적절한 위치에 배포가 가능하다.
- 개발 환경을 컨테이너 기반 가상화 환경으로 구현하고 CI(Continuous Integration)/CD(Continuous Development) 도구 및 개발 방법론을 결합함으로써 코딩, 빌드 및 테스트를 보다 쉽고 빠르게 수행하며 개발 환경 자동화와 손쉬운 운영 환경 배포의 기반을 마련할 수 있다.
- CI 기술은 개발 과정에서 빠른 소프트웨어 수정을 통해 품질 및 배포 속도를 향상시키며, CD 기술은 소프트웨어 업데이트를 업무 애플리케이션에 적용해 변경 사항을 보다 효율적으로 배포하도록 지원한다.
- 컨테이너는 자동화 도구와 결합해 기업들의 개발 및 운영 과정의 민첩성을 향상시킨다.
- 컨테이너 기반 가상화 환경은 컨테이너의 자동화된 배치, 확장 및 운영을 지원하는 오픈소스 관리 플랫폼 쿠버네티스(Kubernetes)와 결합해 사용할 수 있다.
- 데브옵스와 마이크로서비스를 구현하기 위해 필요한 다양한 애플리케이션과 분석 툴을 제공한다.

---

## 마이크로서비스 아키텍처 설계

### 마이크로서비스 아키텍처

![2.3-microservice-architecture.png](images%2F2.3-microservice-architecture.png)

- 자세한 내용은 [가트너 발표 자료](https://www.gartner.com/en/documents/3891779)를 참고한다.

### 마이크로서비스 아키텍처 Components

- **관리 컨테이너**: 개별 서비스 인스턴스에는 작동할 컨텍스트가 필요하다. 가상 컴퓨터, Docker 컨테이너 또는 조정 된 프로세스로 구현 된 관리 컨테이너는 이러한 기능을 제공, 인스턴스 관리 및 조정을 제공하고 필요에 따라 새 인스턴스를 회전하며 개별 인스턴스의 수명주기를 관리한다.
- **외부 게이트웨이**: MSA 구현은 비즈니스 애플리케이션 및 애플리케이션에서 사용할 수 있는 API 형태로 기능을 노출한다. 서비스 외부 게이트웨이는 이러한 서비스에 대한 액세스를 관리하고 트래픽 관리 및 보안 정책을 적용하여 마이크로서비스 환경을 보호한다. 외부 게이트웨이 기능은 종종 API 관리 제품을 사용하여 구현할 수 있다.
- **서비스 메쉬 기능**: 서비스 메쉬는 서비스 간의 통신을 느슨하게 결합, 신뢰성 및 유연성을 유지하는 데 도움이 되는 기능으로 구성되며 서비스 분리, 버전 관리 전략 지원 및 부하시 탄성 확장성 관리가 가능하다. 서비스 라우팅, 로드 밸런싱, 서비스 발견, 구성 저장소, ID 공급자 기능 등을 제공한다.
- **서비스 이미지 레지스트리**: 사용자 환경의 어딘가에는 빌드되고 테스트 된 서비스의 불변 이미지를 저장하는 레지스트리로 동적으로 생성된 서비스의 경우 코드 저장소, Docker 이미지 레지스트리, 이진 아티팩트 저장소 또는 VM 이미지의 BLOB(Binary Large Object) 기반 저장소 등을 제공한다.
- **메시지 지향 미들웨어**: 가장 간단한 MSA 구현은 HTTP와 같은 동기식 프로토콜 또는 gRPC 또는 Thrift와 같은 보다 효율적인 프로토콜을 사용하여 지속 가능하며 이벤트 및 메시지 중심 패턴을 지원하기 위해 비동기 메시징 채널이 필요하다.
- **빌드 및 테스트 자동화**: MSA의 개발 민첩성의 이점은 개발 출력 품질을 그대화하고 전달을 간소화하기 위해 개발주기에서 높은 수준의 빌드 및 테스트 자동화가 필요하다.
- **배포 자동화**: 개발 민첩성의 이점을 완전히 실현하려면 배포를 자동화해야 한다.